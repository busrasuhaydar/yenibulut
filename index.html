<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volumetric Clouds</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: auto;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', {
            alpha: false,
            antialias: false,
            depth: false,
            stencil: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL desteklenmiyor!');
            throw new Error('WebGL not supported');
        }

        function resizeCanvas() {
            // Performans optimizasyonu: DPR'yi düşük tut, yüksek çözünürlük için upscaling kullan
            const dpr = Math.min(window.devicePixelRatio || 1, 1.0);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Kamera kontrolü için değişkenler
        let cameraYaw = 0.0;
        let cameraPitch = 0.3;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        // Mouse ile kamera kontrolü (sürükle-bırak)
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = (e.clientX - lastMouseX) * 0.005;
                const deltaY = (e.clientY - lastMouseY) * 0.005;

                cameraYaw -= deltaX;
                cameraPitch = Math.max(-1.5, Math.min(1.5, cameraPitch - deltaY));

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.style.cursor = 'grab';

        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_cameraYaw;
            uniform float u_cameraPitch;
            uniform vec3 u_cameraOffset;

            mat3 setCamera(vec3 ro, vec3 ta, float cr) {
                vec3 cw = normalize(ta - ro);
                vec3 cp = vec3(sin(cr), cos(cr), 0.0);
                vec3 cu = normalize(cross(cw, cp));
                vec3 cv = normalize(cross(cu, cw));
                return mat3(cu, cv, cw);
            }

            float hash(float n) {
                return fract(sin(n) * 43758.5453123);
            }

            vec3 smootherstep(vec3 t) {
                return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
            }

            float noise(vec3 x) {
                vec3 p = floor(x);
                vec3 f = fract(x);
                f = smootherstep(f);
                
                float n = p.x + p.y * 157.0 + 113.0 * p.z;
                return mix(
                    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                        mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),
                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                        mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y),
                    f.z) * 2.0 - 1.0;
            }

            // 9 oktavlı FBM - En detaylı bulutlar için
            float fbm(vec3 p) {
                float f = 0.0;
                float a = 0.5;
                for(int i = 0; i < 9; i++) {
                    f += a * noise(p);
                    p = p * 2.03;
                    a *= 0.5;
                }
                return f;
            }

            float map5(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = fbm(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            float map4(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = 0.5 * noise(q); q = q * 2.02;
                f += 0.25 * noise(q); q = q * 2.03;
                f += 0.125 * noise(q); q = q * 2.01;
                f += 0.0625 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            float map3(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = 0.5 * noise(q); q = q * 2.02;
                f += 0.25 * noise(q); q = q * 2.03;
                f += 0.125 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            float map2(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = 0.5 * noise(q); q = q * 2.02;
                f += 0.25 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            vec3 calculateLighting(vec3 pos, float den, vec3 sundir, float t) {
                // Performans: Shadow sampling azaltıldı (4->3)
                float shadow = 0.0;
                float st = 0.15;
                for(int i = 0; i < 3; i++) {
                    shadow += map3(pos + sundir * st);
                    st += 0.25;
                }
                shadow = exp(-shadow * 0.75);
                
                float ao = 1.0 - den * 0.4;
                
                vec3 sunColor = vec3(1.6, 0.5, 0.35) * 3.2;
                vec3 skyColor = vec3(0.95, 0.35, 0.65) * 1.6;
                vec3 ambientColor = vec3(1.3, 0.65, 0.55) * 1.1;
                
                float cosTheta = dot(normalize(sundir), normalize(pos));
                float g = 0.6;
                float phase = (1.0 - g * g) / (4.0 * 3.14159 * pow(1.0 + g * g - 2.0 * g * cosTheta, 1.5));
                
                vec3 light = sunColor * shadow * phase * 1.8;
                light += skyColor * ao * 0.85;
                light += ambientColor * (0.55 + 0.35 * den);
                
                return light;
            }

            vec4 raymarch(vec3 ro, vec3 rd, vec3 bgcol) {
                vec4 sum = vec4(0.0);
                float t = 0.0;
                vec3 sundir = normalize(vec3(-0.6, 0.5, -0.8));

                // Performans: Iteration sayısı optimize edildi (35->28)
                for(int i = 0; i < 28; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.98) break;
                    
                    float den = map3(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, t);

                        float denFactor = smoothstep(0.0, 1.0, den);
                        // x3 daha fazla ton - Zengin renk geçişleri
                        vec3 cloudBase = vec3(1.9, 0.85, 0.55);
                        vec3 cloudLight1 = vec3(1.85, 0.8, 0.53);
                        vec3 cloudLight2 = vec3(1.8, 0.75, 0.5);
                        vec3 cloudMid1 = vec3(1.7, 0.65, 0.45);
                        vec3 cloudMid2 = vec3(1.6, 0.6, 0.48);
                        vec3 cloudMid3 = vec3(1.5, 0.55, 0.5);
                        vec3 cloudMid4 = vec3(1.4, 0.5, 0.5);
                        vec3 cloudMid5 = vec3(1.2, 0.45, 0.52);
                        vec3 cloudMid6 = vec3(1.0, 0.4, 0.52);
                        vec3 cloudDark1 = vec3(0.8, 0.35, 0.5);
                        vec3 cloudDark2 = vec3(0.7, 0.32, 0.48);
                        vec3 cloudDark3 = vec3(0.6, 0.28, 0.46);
                        vec3 cloudDark4 = vec3(0.55, 0.25, 0.45);
                        vec3 cloudDark5 = vec3(0.5, 0.23, 0.43);
                        vec3 cloudDeep1 = vec3(0.45, 0.2, 0.4);
                        vec3 cloudDeep2 = vec3(0.4, 0.18, 0.38);
                        vec3 cloudDeep3 = vec3(0.35, 0.16, 0.36);

                        vec3 cloudColor = mix(cloudBase, cloudLight1, denFactor * 0.1);
                        cloudColor = mix(cloudColor, cloudLight2, denFactor * 0.2);
                        cloudColor = mix(cloudColor, cloudMid1, denFactor * 0.3);
                        cloudColor = mix(cloudColor, cloudMid2, denFactor * 0.35);
                        cloudColor = mix(cloudColor, cloudMid3, denFactor * 0.4);
                        cloudColor = mix(cloudColor, cloudMid4, denFactor * 0.5);
                        cloudColor = mix(cloudColor, cloudMid5, denFactor * 0.55);
                        cloudColor = mix(cloudColor, cloudMid6, denFactor * 0.6);
                        cloudColor = mix(cloudColor, cloudDark1, denFactor * 0.7);
                        cloudColor = mix(cloudColor, cloudDark2, denFactor * 0.75);
                        cloudColor = mix(cloudColor, cloudDark3, denFactor * 0.8);
                        cloudColor = mix(cloudColor, cloudDark4, denFactor * 0.85);
                        cloudColor = mix(cloudColor, cloudDark5, denFactor * 0.9);
                        cloudColor = mix(cloudColor, cloudDeep1, denFactor * 0.95);
                        cloudColor = mix(cloudColor, cloudDeep2, denFactor * 0.97);
                        cloudColor = mix(cloudColor, cloudDeep3, denFactor * 0.99);
                        
                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.0018 * t * t));
                        col.w *= 0.4;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.06, 0.05 * t);
                }

                // Performans: İkinci pass iteration sayısı optimize edildi (25->20)
                for(int i = 0; i < 20; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.98) break;
                    
                    float den = map2(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, t);

                        float denFactor = smoothstep(0.0, 1.0, den);
                        // x3 daha fazla ton - Uzak bulutlar için
                        vec3 cloudColor = mix(vec3(1.6, 0.7, 0.45), vec3(1.4, 0.6, 0.47), denFactor * 0.2);
                        cloudColor = mix(cloudColor, vec3(1.2, 0.55, 0.48), denFactor * 0.35);
                        cloudColor = mix(cloudColor, vec3(1.0, 0.5, 0.49), denFactor * 0.5);
                        cloudColor = mix(cloudColor, vec3(0.85, 0.42, 0.495), denFactor * 0.6);
                        cloudColor = mix(cloudColor, vec3(0.7, 0.35, 0.5), denFactor * 0.7);
                        cloudColor = mix(cloudColor, vec3(0.6, 0.3, 0.475), denFactor * 0.8);
                        cloudColor = mix(cloudColor, vec3(0.5, 0.25, 0.45), denFactor * 0.9);
                        
                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.0018 * t * t));
                        col.w *= 0.4;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.08, 0.06 * t);
                }
                
                return clamp(sum, 0.0, 1.0);
            }

            void main() {
                vec2 p = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;

                // Otomatik kamera hareketi - Sonsuz uçuş
                vec3 ro = u_cameraOffset;

                // Mouse ile bakış açısı kontrolü
                float pitch = u_cameraPitch;
                float yaw = u_cameraYaw;

                vec3 lookDir = vec3(
                    cos(pitch) * sin(yaw),
                    sin(pitch),
                    cos(pitch) * cos(yaw)
                );

                vec3 ta = ro + lookDir * 5.0;
                mat3 ca = setCamera(ro, ta, 0.05 * cos(0.25 * u_time));
                vec3 rd = ca * normalize(vec3(p.xy, 1.5));
                
                vec3 sundir = normalize(vec3(-0.6, 0.5, -0.8));
                float sun = clamp(dot(sundir, rd), 0.0, 1.0);
                
                float skyGradient = pow(1.0 - max(rd.y, 0.0), 1.3);
                // x3 daha fazla gökyüzü tonu - Zengin geçişler
                vec3 skyHorizon = vec3(0.9, 0.4, 0.65);
                vec3 skyLow1 = vec3(0.95, 0.42, 0.62);
                vec3 skyLow2 = vec3(1.0, 0.43, 0.6);
                vec3 skyMid1 = vec3(1.1, 0.45, 0.55);
                vec3 skyMid2 = vec3(1.15, 0.46, 0.52);
                vec3 skyMid3 = vec3(1.2, 0.48, 0.48);
                vec3 skyMid4 = vec3(1.3, 0.5, 0.45);
                vec3 skyMid5 = vec3(1.35, 0.51, 0.42);
                vec3 skyMid6 = vec3(1.4, 0.53, 0.4);
                vec3 skyHigh1 = vec3(1.45, 0.54, 0.37);
                vec3 skyHigh2 = vec3(1.5, 0.55, 0.35);
                vec3 skyHigh3 = vec3(1.53, 0.53, 0.33);
                vec3 skyZenith1 = vec3(1.56, 0.51, 0.31);
                vec3 skyZenith2 = vec3(1.6, 0.5, 0.3);

                vec3 col = mix(skyHorizon, skyLow1, skyGradient * 0.15);
                col = mix(col, skyLow2, skyGradient * 0.25);
                col = mix(col, skyMid1, skyGradient * 0.35);
                col = mix(col, skyMid2, skyGradient * 0.42);
                col = mix(col, skyMid3, skyGradient * 0.48);
                col = mix(col, skyMid4, skyGradient * 0.55);
                col = mix(col, skyMid5, skyGradient * 0.62);
                col = mix(col, skyMid6, skyGradient * 0.68);
                col = mix(col, skyHigh1, skyGradient * 0.75);
                col = mix(col, skyHigh2, skyGradient * 0.82);
                col = mix(col, skyHigh3, skyGradient * 0.9);
                col = mix(col, skyZenith1, skyGradient * 0.95);
                col = mix(col, skyZenith2, skyGradient);
                
                col += vec3(1.9, 0.65, 0.35) * pow(sun, 12.0) * 0.7;
                col += vec3(1.7, 0.5, 0.4) * pow(sun, 6.0) * 0.5;
                col += vec3(1.5, 0.45, 0.5) * pow(sun, 3.5) * 0.4;
                
                vec4 res = raymarch(ro, rd, col);
                col = col * (1.0 - res.w) + res.xyz;
                
                col += vec3(1.3, 0.55, 0.35) * pow(sun, 2.8) * (1.0 - res.w) * 0.6;
                
                col = pow(col, vec3(0.82));
                col = col * 1.25;
                col = mix(col, vec3(dot(col, vec3(0.299, 0.587, 0.114))), -0.22);
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader derleme hatası:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program bağlama hatası:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const cameraYawLocation = gl.getUniformLocation(program, 'u_cameraYaw');
        const cameraPitchLocation = gl.getUniformLocation(program, 'u_cameraPitch');
        const cameraOffsetLocation = gl.getUniformLocation(program, 'u_cameraOffset');

        const startTime = Date.now();

        function render() {
            const currentTime = (Date.now() - startTime) / 1000;

            // Otomatik ileri hareket - Sonsuz uçuş
            const speed = 0.3; // Yavaş hareket
            const cameraZ = currentTime * speed;
            const cameraY = -0.5 + Math.sin(currentTime * 0.1) * 0.2; // Hafif yukarı-aşağı
            const cameraX = Math.sin(currentTime * 0.05) * 0.3; // Hafif sağa-sola

            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, currentTime);
            gl.uniform1f(cameraYawLocation, cameraYaw);
            gl.uniform1f(cameraPitchLocation, cameraPitch);
            gl.uniform3f(cameraOffsetLocation, cameraX, cameraY, cameraZ);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>
