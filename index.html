<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volumetric Clouds - WebGL Shader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: auto;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="info">
        Volumetric Clouds by Inigo Quilez<br>
        Move mouse to control camera
    </div>
    <canvas id="glCanvas"></canvas>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', {
            alpha: false,
            antialias: true,
            depth: false,
            stencil: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL desteklenmiyor!');
            throw new Error('WebGL not supported');
        }

        function resizeCanvas() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Mouse tracking
        let mouseX = 0.5;
        let mouseY = 0.5;
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX / window.innerWidth;
            mouseY = 1.0 - (e.clientY / window.innerHeight);
        });

        // Vertex Shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment Shader (Enhanced version with better lighting)
        const fragmentShaderSource = `
            precision highp float;
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec2 u_mouse;

            mat3 setCamera(vec3 ro, vec3 ta, float cr) {
                vec3 cw = normalize(ta - ro);
                vec3 cp = vec3(sin(cr), cos(cr), 0.0);
                vec3 cu = normalize(cross(cw, cp));
                vec3 cv = normalize(cross(cu, cw));
                return mat3(cu, cv, cw);
            }

            float hash(float n) {
                return fract(sin(n) * 43758.5453123);
            }

            vec3 smootherstep(vec3 t) {
                return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
            }

            float noise(vec3 x) {
                vec3 p = floor(x);
                vec3 f = fract(x);
                f = smootherstep(f);
                
                float n = p.x + p.y * 157.0 + 113.0 * p.z;
                return mix(
                    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                        mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),
                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                        mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y),
                    f.z) * 2.0 - 1.0;
            }

            float fbm(vec3 p) {
                float f = 0.0;
                float a = 0.5;
                for(int i = 0; i < 6; i++) {
                    f += a * noise(p);
                    p = p * 2.02;
                    a *= 0.5;
                }
                return f;
            }

            float map5(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = fbm(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            float map4(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = 0.5 * noise(q);
                q = q * 2.02;
                f += 0.25 * noise(q);
                q = q * 2.03;
                f += 0.125 * noise(q);
                q = q * 2.01;
                f += 0.0625 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            float map3(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = 0.5 * noise(q);
                q = q * 2.02;
                f += 0.25 * noise(q);
                q = q * 2.03;
                f += 0.125 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            float map2(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = 0.5 * noise(q);
                q = q * 2.02;
                f += 0.25 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            vec3 calculateLighting(vec3 pos, float den, vec3 sundir, vec3 bgcol, float t) {
                float shadow = 0.0;
                float st = 0.1;
                for(int i = 0; i < 6; i++) {
                    shadow += map5(pos + sundir * st);
                    st += 0.15;
                }
                shadow = exp(-shadow * 0.8);
                
                float ao = 1.0 - den * 0.5;
                
                vec3 sunColor = vec3(1.5, 0.45, 0.3) * 3.5;
                vec3 skyColor = vec3(0.9, 0.3, 0.6) * 1.8;
                vec3 ambientColor = vec3(1.2, 0.6, 0.5) * 1.2;
                
                float cosTheta = dot(normalize(sundir), normalize(pos));
                float g = 0.65;
                float phase = (1.0 - g * g) / (4.0 * 3.14159 * pow(1.0 + g * g - 2.0 * g * cosTheta, 1.5));
                
                vec3 light = sunColor * shadow * phase * 2.0;
                light += skyColor * ao * 0.9;
                light += ambientColor * (0.6 + 0.4 * den);
                
                return light;
            }

            vec4 raymarch(vec3 ro, vec3 rd, vec3 bgcol) {
                vec4 sum = vec4(0.0);
                float t = 0.0;
                vec3 sundir = normalize(vec3(-0.6, 0.5, -0.8));
                
                for(int i = 0; i < 50; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.99) break;
                    
                    float den = map5(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, bgcol, t);
                        vec3 cloudColor = mix(
                            vec3(1.8, 0.8, 0.5),
                            vec3(0.5, 0.2, 0.4),
                            smoothstep(0.0, 1.0, den)
                        );
                        
                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.002 * t * t));
                        col.w *= 0.35;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.04, 0.04 * t);
                }
                
                for(int i = 0; i < 40; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.99) break;
                    
                    float den = map4(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, bgcol, t);
                        vec3 cloudColor = mix(vec3(1.7, 0.75, 0.45), vec3(0.55, 0.25, 0.45), smoothstep(0.0, 1.0, den));
                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.002 * t * t));
                        col.w *= 0.35;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.05, 0.04 * t);
                }
                
                for(int i = 0; i < 35; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.99) break;
                    
                    float den = map3(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, bgcol, t);
                        vec3 cloudColor = mix(vec3(1.6, 0.7, 0.4), vec3(0.6, 0.3, 0.5), smoothstep(0.0, 1.0, den));
                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.002 * t * t));
                        col.w *= 0.35;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.06, 0.05 * t);
                }
                
                for(int i = 0; i < 35; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.99) break;
                    
                    float den = map2(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, bgcol, t);
                        vec3 cloudColor = mix(vec3(1.5, 0.65, 0.35), vec3(0.65, 0.35, 0.55), smoothstep(0.0, 1.0, den));
                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.002 * t * t));
                        col.w *= 0.35;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.07, 0.06 * t);
                }
                
                return clamp(sum, 0.0, 1.0);
            }

            void main() {
                vec2 p = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;
                vec2 m = u_mouse.xy / u_resolution.xy;
                
                vec3 ro = 4.0 * normalize(vec3(sin(3.0 * m.x), 0.8 * m.y, cos(3.0 * m.x))) - vec3(0.0, 0.1, 0.0);
                vec3 ta = vec3(0.0, -1.0, 0.0);
                mat3 ca = setCamera(ro, ta, 0.07 * cos(0.25 * u_time));
                vec3 rd = ca * normalize(vec3(p.xy, 1.5));
                
                vec3 sundir = normalize(vec3(-0.6, 0.5, -0.8));
                float sun = clamp(dot(sundir, rd), 0.0, 1.0);
                
                vec3 col = mix(
                    vec3(0.85, 0.35, 0.6),
                    vec3(1.5, 0.5, 0.3),
                    pow(1.0 - max(rd.y, 0.0), 1.2)
                );
                
                col += vec3(1.8, 0.6, 0.3) * pow(sun, 10.0) * 0.8;
                col += vec3(1.5, 0.4, 0.4) * pow(sun, 4.0) * 0.6;
                
                vec4 res = raymarch(ro, rd, col);
                col = col * (1.0 - res.w) + res.xyz;
                
                col += vec3(1.2, 0.5, 0.3) * pow(sun, 2.5) * (1.0 - res.w);
                
                col = pow(col, vec3(0.8));
                col = col * 1.3;
                col = mix(col, vec3(dot(col, vec3(0.299, 0.587, 0.114))), -0.25);
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader derleme hatası:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program bağlama hatası:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const mouseLocation = gl.getUniformLocation(program, 'u_mouse');

        const startTime = Date.now();

        function render() {
            const currentTime = (Date.now() - startTime) / 1000;

            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, currentTime);
            gl.uniform2f(mouseLocation, mouseX * canvas.width, mouseY * canvas.height);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>