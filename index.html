<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Volumetric Clouds - WebGL Shader</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: auto;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>

    <script>
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl', {
            alpha: false,
            antialias: true,
            depth: false,
            stencil: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false,
            powerPreference: 'high-performance'
        });

        if (!gl) {
            alert('WebGL desteklenmiyor!');
            throw new Error('WebGL not supported');
        }

        function resizeCanvas() {
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Mouse drag tracking
        let mouseX = 0.5;
        let mouseY = 0.5;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = (e.clientX - lastMouseX) / window.innerWidth;
                const deltaY = (e.clientY - lastMouseY) / window.innerHeight;

                mouseX += deltaX;
                mouseY -= deltaY;

                // Keep within bounds
                mouseX = Math.max(0.0, Math.min(1.0, mouseX));
                mouseY = Math.max(0.0, Math.min(1.0, mouseY));

                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
        });

        canvas.style.cursor = 'grab';

        // Vertex Shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;

        // Fragment Shader (Enhanced version with better lighting)
        const fragmentShaderSource = `
            precision highp float;
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform vec2 u_mouse;

            mat3 setCamera(vec3 ro, vec3 ta, float cr) {
                vec3 cw = normalize(ta - ro);
                vec3 cp = vec3(sin(cr), cos(cr), 0.0);
                vec3 cu = normalize(cross(cw, cp));
                vec3 cv = normalize(cross(cu, cw));
                return mat3(cu, cv, cw);
            }

            float hash(float n) {
                return fract(sin(n) * 43758.5453123);
            }

            vec3 smootherstep(vec3 t) {
                return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
            }

            float noise(vec3 x) {
                vec3 p = floor(x);
                vec3 f = fract(x);
                f = smootherstep(f);
                
                float n = p.x + p.y * 157.0 + 113.0 * p.z;
                return mix(
                    mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                        mix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),
                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                        mix(hash(n + 270.0), hash(n + 271.0), f.x), f.y),
                    f.z) * 2.0 - 1.0;
            }

            float fbm(vec3 p) {
                float f = 0.0;
                float a = 0.5;
                for(int i = 0; i < 4; i++) {
                    f += a * noise(p);
                    p = p * 2.02;
                    a *= 0.5;
                }
                return f;
            }

            float map5(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = fbm(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            float map4(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = 0.5 * noise(q);
                q = q * 2.02;
                f += 0.25 * noise(q);
                q = q * 2.03;
                f += 0.125 * noise(q);
                q = q * 2.01;
                f += 0.0625 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            float map3(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = 0.5 * noise(q);
                q = q * 2.02;
                f += 0.25 * noise(q);
                q = q * 2.03;
                f += 0.125 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            float map2(vec3 p) {
                vec3 q = p - vec3(0.0, 0.1, 1.0) * u_time * 0.08;
                float f = 0.5 * noise(q);
                q = q * 2.02;
                f += 0.25 * noise(q);
                return clamp(1.5 - p.y - 2.0 + 1.75 * f, 0.0, 1.0);
            }

            vec3 calculateLighting(vec3 pos, float den, vec3 sundir, vec3 bgcol, float t) {
                float shadow = 0.0;
                float st = 0.15;
                for(int i = 0; i < 4; i++) {
                    shadow += map5(pos + sundir * st);
                    st += 0.22;
                }
                shadow = exp(-shadow * 0.8);

                float ao = 1.0 - den * 0.5;

                // Softer lighting colors - reduced brightness
                vec3 sunColor = vec3(1.2, 0.4, 0.3) * 2.2;
                vec3 skyColor = vec3(0.7, 0.25, 0.5) * 1.3;
                vec3 ambientColor = vec3(0.9, 0.5, 0.45) * 0.9;
                vec3 backLight = vec3(0.6, 0.3, 0.55) * 1.0;

                float cosTheta = dot(normalize(sundir), normalize(pos));
                float g = 0.65;
                float phase = (1.0 - g * g) / (4.0 * 3.14159 * pow(1.0 + g * g - 2.0 * g * cosTheta, 1.5));

                vec3 light = sunColor * shadow * phase * 2.0;
                light += skyColor * ao * 0.9;
                light += ambientColor * (0.6 + 0.4 * den);
                light += backLight * (1.0 - shadow) * 0.4;

                return light;
            }

            vec4 raymarch(vec3 ro, vec3 rd, vec3 bgcol) {
                vec4 sum = vec4(0.0);
                float t = 0.0;
                vec3 sundir = normalize(vec3(-0.6, 0.5, -0.8));
                
                for(int i = 0; i < 28; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.99) break;

                    float den = map5(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, bgcol, t);
                        // Soft pink and white tones - 8 variations
                        vec3 white1 = vec3(0.95, 0.93, 0.95);  // Pure soft white
                        vec3 white2 = vec3(0.98, 0.88, 0.92);  // Pink-tinted white
                        vec3 pink1 = vec3(0.95, 0.75, 0.80);   // Very soft pink
                        vec3 pink2 = vec3(0.90, 0.65, 0.75);   // Light pink
                        vec3 pink3 = vec3(0.85, 0.55, 0.70);   // Medium soft pink
                        vec3 pink4 = vec3(0.75, 0.45, 0.65);   // Deeper pink
                        vec3 pink5 = vec3(0.65, 0.35, 0.60);   // Rich pink
                        vec3 shadow = vec3(0.45, 0.25, 0.50);  // Pink shadow

                        float t1 = smoothstep(0.0, 0.15, den);
                        float t2 = smoothstep(0.15, 0.35, den);
                        float t3 = smoothstep(0.35, 0.55, den);
                        float t4 = smoothstep(0.55, 0.75, den);
                        float t5 = smoothstep(0.75, 1.0, den);

                        vec3 cloudColor = mix(white1, white2, t1);
                        cloudColor = mix(cloudColor, pink1, t2);
                        cloudColor = mix(cloudColor, pink2, t3);
                        cloudColor = mix(cloudColor, pink3, t4);
                        cloudColor = mix(cloudColor, pink4, t5);

                        // Position-based variation
                        float variation = sin(pos.x * 0.3) * cos(pos.z * 0.4);
                        cloudColor = mix(cloudColor, pink5, variation * 0.15);

                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.002 * t * t));
                        col.w *= 0.35;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.05, 0.05 * t);
                }

                for(int i = 0; i < 22; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.99) break;

                    float den = map4(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, bgcol, t);
                        // Second layer - slightly warmer pink/white tones
                        vec3 white1 = vec3(0.96, 0.90, 0.93);
                        vec3 white2 = vec3(0.92, 0.82, 0.88);
                        vec3 pink1 = vec3(0.88, 0.70, 0.78);
                        vec3 pink2 = vec3(0.82, 0.60, 0.72);
                        vec3 pink3 = vec3(0.76, 0.50, 0.68);
                        vec3 pink4 = vec3(0.68, 0.40, 0.62);
                        vec3 pink5 = vec3(0.60, 0.32, 0.58);

                        float t1 = smoothstep(0.0, 0.15, den);
                        float t2 = smoothstep(0.15, 0.35, den);
                        float t3 = smoothstep(0.35, 0.55, den);
                        float t4 = smoothstep(0.55, 0.75, den);

                        vec3 cloudColor = mix(white1, white2, t1);
                        cloudColor = mix(cloudColor, pink1, t2);
                        cloudColor = mix(cloudColor, pink2, t3);
                        cloudColor = mix(cloudColor, pink3, t4);

                        float variation = cos(pos.z * 0.35) * sin(pos.y * 0.25);
                        cloudColor = mix(cloudColor, pink4, variation * 0.12);

                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.002 * t * t));
                        col.w *= 0.35;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.06, 0.055 * t);
                }

                for(int i = 0; i < 18; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.99) break;

                    float den = map3(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, bgcol, t);
                        // Third layer - rosy pink/white tones
                        vec3 white1 = vec3(0.94, 0.87, 0.90);
                        vec3 white2 = vec3(0.90, 0.78, 0.85);
                        vec3 pink1 = vec3(0.85, 0.68, 0.76);
                        vec3 pink2 = vec3(0.78, 0.58, 0.70);
                        vec3 pink3 = vec3(0.72, 0.48, 0.65);
                        vec3 pink4 = vec3(0.64, 0.38, 0.60);
                        vec3 pink5 = vec3(0.56, 0.30, 0.55);

                        float t1 = smoothstep(0.0, 0.15, den);
                        float t2 = smoothstep(0.15, 0.35, den);
                        float t3 = smoothstep(0.35, 0.55, den);
                        float t4 = smoothstep(0.55, 0.75, den);

                        vec3 cloudColor = mix(white1, white2, t1);
                        cloudColor = mix(cloudColor, pink1, t2);
                        cloudColor = mix(cloudColor, pink2, t3);
                        cloudColor = mix(cloudColor, pink3, t4);

                        float variation = sin(pos.y * 0.5) * cos(pos.x * 0.3);
                        cloudColor = mix(cloudColor, pink4, variation * 0.1);

                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.002 * t * t));
                        col.w *= 0.35;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.08, 0.065 * t);
                }

                for(int i = 0; i < 16; i++) {
                    vec3 pos = ro + t * rd;
                    if(pos.y < -3.0 || pos.y > 2.0 || sum.a > 0.99) break;

                    float den = map2(pos);
                    if(den > 0.01) {
                        vec3 light = calculateLighting(pos, den, sundir, bgcol, t);
                        // Fourth layer - distant soft pink/white tones
                        vec3 white1 = vec3(0.92, 0.84, 0.88);
                        vec3 white2 = vec3(0.88, 0.75, 0.82);
                        vec3 pink1 = vec3(0.82, 0.65, 0.74);
                        vec3 pink2 = vec3(0.75, 0.55, 0.68);
                        vec3 pink3 = vec3(0.68, 0.45, 0.62);
                        vec3 pink4 = vec3(0.60, 0.36, 0.58);
                        vec3 pink5 = vec3(0.52, 0.28, 0.52);

                        float t1 = smoothstep(0.0, 0.15, den);
                        float t2 = smoothstep(0.15, 0.35, den);
                        float t3 = smoothstep(0.35, 0.55, den);
                        float t4 = smoothstep(0.55, 0.75, den);

                        vec3 cloudColor = mix(white1, white2, t1);
                        cloudColor = mix(cloudColor, pink1, t2);
                        cloudColor = mix(cloudColor, pink2, t3);
                        cloudColor = mix(cloudColor, pink3, t4);

                        float variation = cos(pos.x * 0.25 + pos.z * 0.25);
                        cloudColor = mix(cloudColor, pink4, variation * 0.08);

                        vec4 col = vec4(cloudColor * light, den);
                        col.xyz = mix(col.xyz, bgcol, 1.0 - exp(-0.002 * t * t));
                        col.w *= 0.35;
                        col.rgb *= col.a;
                        sum += col * (1.0 - sum.a);
                    }
                    t += max(0.09, 0.07 * t);
                }

                return clamp(sum, 0.0, 1.0);
            }

            void main() {
                vec2 p = (2.0 * gl_FragCoord.xy - u_resolution.xy) / u_resolution.y;
                vec2 m = u_mouse.xy / u_resolution.xy;
                
                vec3 ro = 4.0 * normalize(vec3(sin(3.0 * m.x), 0.8 * m.y, cos(3.0 * m.x))) - vec3(0.0, 0.1, 0.0);
                vec3 ta = vec3(0.0, -1.0, 0.0);
                mat3 ca = setCamera(ro, ta, 0.07 * cos(0.25 * u_time));
                vec3 rd = ca * normalize(vec3(p.xy, 1.5));
                
                vec3 sundir = normalize(vec3(-0.6, 0.5, -0.8));
                float sun = clamp(dot(sundir, rd), 0.0, 1.0);

                // Rich orange gradient with 8+ tones
                float skyGradient = pow(1.0 - max(rd.y, 0.0), 1.2);

                // 8 layers of orange/pink/purple tones
                vec3 zenith = vec3(0.60, 0.25, 0.50);      // Deep purple zenith
                vec3 upper = vec3(0.70, 0.30, 0.52);       // Purple-pink
                vec3 midUpper = vec3(0.80, 0.38, 0.48);    // Pink-purple
                vec3 middle = vec3(0.90, 0.45, 0.42);      // Rosy pink
                vec3 midLower = vec3(1.00, 0.52, 0.38);    // Coral orange
                vec3 lower = vec3(1.10, 0.58, 0.32);       // Peachy orange
                vec3 nearHorizon = vec3(1.18, 0.62, 0.28); // Warm orange
                vec3 horizon = vec3(1.25, 0.65, 0.25);     // Golden orange

                // Smooth 8-layer gradient
                vec3 col = mix(zenith, upper, smoothstep(0.0, 0.14, skyGradient));
                col = mix(col, midUpper, smoothstep(0.14, 0.28, skyGradient));
                col = mix(col, middle, smoothstep(0.28, 0.42, skyGradient));
                col = mix(col, midLower, smoothstep(0.42, 0.58, skyGradient));
                col = mix(col, lower, smoothstep(0.58, 0.72, skyGradient));
                col = mix(col, nearHorizon, smoothstep(0.72, 0.86, skyGradient));
                col = mix(col, horizon, smoothstep(0.86, 1.0, skyGradient));

                // Add subtle orange variations based on azimuth
                float azimuth = atan(rd.z, rd.x);
                vec3 orangeVar1 = vec3(1.15, 0.55, 0.25);
                vec3 orangeVar2 = vec3(1.05, 0.48, 0.35);
                col += mix(orangeVar1, orangeVar2, sin(azimuth * 2.0) * 0.5 + 0.5) * 0.08 * skyGradient;

                // Softer sun glow with warm orange tones
                col += vec3(1.30, 0.60, 0.25) * pow(sun, 10.0) * 0.6;
                col += vec3(1.15, 0.52, 0.32) * pow(sun, 4.0) * 0.5;
                col += vec3(1.00, 0.45, 0.40) * pow(sun, 2.0) * 0.3;
                
                vec4 res = raymarch(ro, rd, col);
                col = col * (1.0 - res.w) + res.xyz;
                
                col += vec3(1.2, 0.5, 0.3) * pow(sun, 2.5) * (1.0 - res.w);
                
                col = pow(col, vec3(0.8));
                col = col * 1.3;
                col = mix(col, vec3(dot(col, vec3(0.299, 0.587, 0.114))), -0.25);
                
                gl_FragColor = vec4(col, 1.0);
            }
        `;

        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader derleme hatası:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Program bağlama hatası:', gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        const vertices = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1
        ]);

        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        const mouseLocation = gl.getUniformLocation(program, 'u_mouse');

        const startTime = Date.now();

        function render() {
            const currentTime = (Date.now() - startTime) / 1000;

            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(timeLocation, currentTime);
            gl.uniform2f(mouseLocation, mouseX * canvas.width, mouseY * canvas.height);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        render();
    </script>
</body>
</html>